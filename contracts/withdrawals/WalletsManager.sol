pragma solidity 0.5.12;

import "@openzeppelin/upgrades/contracts/Initializable.sol";
import "@openzeppelin/upgrades/contracts/upgradeability/AdminUpgradeabilityProxy.sol";
import "../access/Admins.sol";
import "../validators/ValidatorsRegistry.sol";
import "./Withdrawals.sol";

/**
 * @title WalletsManager
 * WalletsManager creates and assigns wallets to validators.
 * The deposits and rewards generated by the validator will be withdrawn to the wallet it was assigned.
 * To reuse wallets multiple times for different validators, a user with an admin
 * role can reset the wallet when all the users have withdrawn their shares.
 */
contract WalletsManager is Initializable {
    /**
    * Structure to store information about the wallet.
    * @param unlocked - indicates whether users can withdraw from the wallet.
    * @param validator - the validator wallet is attached to.
    */
    struct Wallet {
        bool unlocked;
        bytes32 validator;
    }

    // Determines whether validator ID (public key hash) has been assigned any wallet.
    // Required to prevent assigning multiple wallets to the same validator.
    mapping(bytes32 => bool) public assignedValidators;

    // Maps wallet address to the information about it.
    mapping(address => Wallet) public wallets;

    // Proxy admin is a contract which can upgrade created wallets in the future.
    address private proxyAdmin;

    // An address of the wallet implementation contract.
    address private walletImplementation;

    // An encoded call data used to initialize the new wallet.
    bytes private walletCreationData;

    // Stores list of available wallets.
    address[] private availableWallets;

    // Address of the Admins contract.
    Admins private admins;

    // Address of the ValidatorsRegistry contract.
    ValidatorsRegistry private validatorsRegistry;

    // Address of the Withdrawals contract.
    Withdrawals private withdrawals;

    /**
    * Event for tracking created wallets.
    * @param wallet - an address of the created Wallet contract.
    */
    event WalletCreated(
        address indexed wallet
    );

    /**
    * Event for tracking wallet's new assignment.
    * @param validator - ID (public key hash) of the validator wallet was assigned to.
    * @param wallet - address of the wallet the deposits and rewards will be withdrawn to.
    */
    event WalletAssigned(
        bytes32 indexed validator,
        address indexed wallet
    );

    /**
    * Event for tracking wallet's resets.
    * @param wallet - address of the reset wallet.
    */
    event WalletReset(
        address indexed wallet
    );

    /**
    * Constructor for initializing the WalletsManager contract.
    * @param _admins - Address of the Admins contract.
    * @param _validatorsRegistry - Address of the Validators Registry contract.
    * @param _withdrawals - Address of the Withdrawals contract.
    * @param _proxyAdmin - Address of the ProxyAdmin contract.
    * @param _walletImplementation - Address of the Wallet implementation contract.
    * @param _walletCreationData - Encoded call of the Wallet's `initialize` method.
    */
    function initialize(
        Admins _admins,
        ValidatorsRegistry _validatorsRegistry,
        Withdrawals _withdrawals,
        address _proxyAdmin,
        address _walletImplementation,
        bytes memory _walletCreationData
    )
        public initializer
    {
        admins = _admins;
        validatorsRegistry = _validatorsRegistry;
        withdrawals = _withdrawals;
        proxyAdmin = _proxyAdmin;
        walletImplementation = _walletImplementation;
        walletCreationData = _walletCreationData;
    }

    /**
    * Function for assigning wallets to validators.
    * Can only be called by users with an admin role.
    * @param _validator - ID (public key hash) of the validator wallet should be assigned to.
    */
    function assignWallet(bytes32 _validator) external {
        require(!assignedValidators[_validator], "Validator has already wallet assigned.");

        (uint256 validatorAmount, ,) = validatorsRegistry.validators(_validator);
        require(validatorAmount != 0, "Validator does not have deposit amount.");
        require(admins.isAdmin(msg.sender), "Permission denied.");

        address wallet;
        // Check whether previous wallets could be reused
        if (availableWallets.length > 0) {
            wallet = availableWallets[availableWallets.length - 1];
            availableWallets.pop();
        } else {
            wallet = createWallet();
            emit WalletCreated(wallet);
        }

        wallets[wallet].validator = _validator;
        assignedValidators[_validator] = true;

        emit WalletAssigned(_validator, wallet);
    }

    /**
    * Private function for creating new wallets.
    * Creates a proxy which could be upgraded by ProxyAdmin.
    * @return wallet - created Wallet contract.
    */
    function createWallet() private returns (address wallet) {
        wallet = address(new AdminUpgradeabilityProxy(
            walletImplementation,
            proxyAdmin,
            walletCreationData
        ));
    }

    /**
    * Function for resetting wallets.
    * Can only be called by users with an admin role.
    * Must be called only when all the users have withdrawn their shares.
    * @param _wallet - Address of the wallet to reset.
    */
    function resetWallet(address _wallet) external {
        require(admins.isAdmin(msg.sender), "Permission denied.");
        require(wallets[_wallet].validator[0] != 0, "Wallet has been already reset.");

        delete wallets[_wallet];
        availableWallets.push(_wallet);
        emit WalletReset(_wallet);
    }

    /**
    * Function for unlocking wallets.
    * Can only be called by Withdrawals contract.
    * By enabling withdrawals, users will be able to start withdrawing their shares.
    * @param _wallet - Address of the wallet to reset.
    */
    function unlockWallet(address _wallet) external {
        require(msg.sender == address(withdrawals), "Permission denied.");
        require(!wallets[_wallet].unlocked, "Wallet is already unlocked.");

        wallets[_wallet].unlocked = true;
    }
}
